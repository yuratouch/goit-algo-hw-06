import heapq
import networkx as nx
import matplotlib.pyplot as plt

# Створення графа
G = nx.Graph()

# Додавання вузлів (станції метро)
stations = ["Академмістечко", "Житомирська", "Святошин", "Нивки", "Берестейська", "Шулявська", "Політехнічний інститут", 
            "Вокзальна", "Університет", "Театральна", "Хрещатик", "Арсенальна", "Дніпро", "Гідропарк", "Лівобережна",
            "Дарниця", "Чернігівська", "Лісова",
            "Героїв Дніпра", "Мінська", "Оболонь", "Почайна", "Тараса Шевченка", "Контрактова площа", 
            "Поштова площа", "Майдан Незалежності", "Площа Льва Толстого", "Олімпійська", "Палац Україна", 
            "Либідська", "Деміївська", "Голосіївська", "Васильківська", "Виставковий центр", "Іподром", "Теремки",
            "Сирець", "Дорогожичі", "Лук'янівська", "Золоті ворота", "Палац Спорту", "Кловська", "Печерська", 
            "Дружби народів", "Видубичі", "Славутич", "Осокорки", "Позняки", "Харківська", "Вирлиця", "Бориспільська", "Червоний Хутір"]

G.add_nodes_from(stations)

# Додавання ребер з вагами (маршрути між станціями)
edges = [("Академмістечко", "Житомирська", 2), ("Житомирська", "Святошин", 2), ("Святошин", "Нивки", 2), 
         ("Нивки", "Берестейська", 2), ("Берестейська", "Шулявська", 2), ("Шулявська", "Політехнічний інститут", 2), 
         ("Політехнічний інститут", "Вокзальна", 2), ("Вокзальна", "Університет", 2), ("Університет", "Театральна", 2), 
         ("Театральна", "Хрещатик", 2), ("Хрещатик", "Арсенальна", 2), ("Арсенальна", "Дніпро", 2), 
         ("Дніпро", "Гідропарк", 2), ("Гідропарк", "Лівобережна", 2), ("Лівобережна", "Дарниця", 2), 
         ("Дарниця", "Чернігівська", 2), ("Чернігівська", "Лісова", 2), 
         ("Героїв Дніпра", "Мінська", 2), ("Мінська", "Оболонь", 2), ("Оболонь", "Почайна", 2), ("Почайна", "Тараса Шевченка", 2), 
         ("Тараса Шевченка", "Контрактова площа", 2), ("Контрактова площа", "Поштова площа", 2), 
         ("Поштова площа", "Майдан Незалежності", 2), ("Майдан Незалежності", "Хрещатик", 1), ("Майдан Незалежності", "Площа Льва Толстого", 2), 
         ("Площа Льва Толстого", "Олімпійська", 2), ("Олімпійська", "Палац Україна", 2), 
         ("Палац Україна", "Либідська", 2), ("Либідська", "Деміївська", 2), ("Деміївська", "Голосіївська", 2), 
         ("Голосіївська", "Васильківська", 2), ("Васильківська", "Виставковий центр", 2), ("Виставковий центр", "Іподром", 2), 
         ("Іподром", "Теремки", 2), 
         ("Сирець", "Дорогожичі", 2), ("Дорогожичі", "Лук'янівська", 2), 
         ("Лук'янівська", "Золоті ворота", 2), ("Золоті ворота", "Театральна", 1), ("Золоті ворота", "Палац Спорту", 2), 
         ("Палац Спорту", "Кловська", 2), ("Палац Спорту", "Площа Льва Толстого", 1), 
         ("Кловська", "Печерська", 2), ("Печерська", "Дружби народів", 2), ("Дружби народів", "Видубичі", 2), 
         ("Видубичі", "Славутич", 2), ("Славутич", "Осокорки", 2), ("Осокорки", "Позняки", 2), 
         ("Позняки", "Харківська", 2), ("Харківська", "Вирлиця", 2), ("Вирлиця", "Бориспільська", 2), 
         ("Бориспільська", "Червоний Хутір", 2)]

G.add_weighted_edges_from(edges)

# Перевірка зв'язності графа
if not nx.is_connected(G):
    print("Граф не є зв'язним. Деякі станції не мають шляху до інших.")
else:
    print("Граф є зв'язним. Усі станції мають шлях до інших.")

# Візуалізація графа з вагами
plt.figure(figsize=(14, 10))
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray', font_size=10)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Київський метрополітен з вагами")
plt.show()

# Реалізація алгоритму Дейкстри без вбудованих рішень
def dijkstra(G, start):
    # Ініціалізація відстаней
    distances = {node: float('inf') for node in G.nodes}
    distances[start] = 0
    priority_queue = [(0, start)]
    shortest_path_tree = {}

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        # Якщо знайдена відстань більша, ніж записана, продовжуємо
        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in G[current_node].items():
            distance = current_distance + weight['weight']

            # Якщо знайдена коротша відстань, оновлюємо
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
                shortest_path_tree[neighbor] = current_node

    return distances, shortest_path_tree

# Використання алгоритму Дейкстри для знаходження найкоротшого шляху між усіма вершинами
shortest_paths = {}
for start in G.nodes:
    distances, _ = dijkstra(G, start)
    shortest_paths[start] = distances

# Виведення найкоротших шляхів між усіма вершинами
for source in shortest_paths:
    for target in shortest_paths[source]:
        print(f"Найкоротший шлях від {source} до {target}: {shortest_paths[source][target]}")
